# Семестровая работа по Базам Данных


## Предметная область базы данных

Данная база данных предназначена для веб-приложения с рецептами и составлять персональные подборки с ними.
А также существует лист покупок, если пользователь захочет приготовить какой-то рецепт, 
но у него не будет нужных ингредиентов, ему не придется держать это в голове, "в пару кликов" добавить ингредиент в лист
(это уже бизнес слой сервиса).

Каждому рецепту пользователь может задать теги, категории и ингредиенты
(которые заранее внесены в систему, изменять могут только админы).

Ведется учет просмотра рецептов, а также пользователи в праве оставить отзывы на любой рецепт
(только один отзыв от одного пользователя на рецепт).


### Сущности

Все сущности (кроме просмотров) обладают временными метками для управления их жизненного цикла

#### Основные сущности
* `user` — пользователь системы. Содержит учетные данные, информацию о профиле.
* `recipe` — рецепт. Основная публикуемая единица, содержит название, описание, время приготовления, 
количество порций, изображение, а также агрегированные показатели просмотров и рейтинга.
* `review` — отзыв на рецепт. Включает оценку (1-5) и текстовый комментарий, оставленный пользователем.
* `shop_list` — список покупок. Принадлежит пользователю и содержит набор ингредиентов для закупки.
* `collection` — коллекция рецептов. Позволяет пользователю группировать рецепты по тематике.

#### Сущность для безопасности
* `session` — сессия пользователя. Хранит идентификатор сессии, ссылку на пользователя и время истечения 
для управления аутентификацией.

#### Сущности для фильтрации и классификации
* `ingredient` — ингредиент. Справочник пищевых продуктов с возможностью иерархической организации.
* `category` — категория рецептов. Иерархическая структура для тематической группировки рецептов.
* `tag` — тег. Гибкая метка для дополнительной пометки рецептов.

#### Структурные сущности
* `recipe_view` — факт просмотра рецепта. Фиксирует, какой пользователь (или аноним) когда просматривал рецепт. 
Используется для статистики и рекомендаций.
* `recipe_step` — шаг приготовления. Часть инструкции рецепта с порядковым номером, 
описанием и опциональным изображением.


---


## Обоснование выбора типов данных

* `created_at`, `deleted_at` и `updated_at` - одинаково типа для удобства сравнения, также время нужно временная зона
нужна для того, чтобы пользователь корректно видел время, кому-то явно не понравиться увидеть, 
что рецепт, который он загрузил сегодня, отображается у него как вчерашний, 
время в принципе нужно для удобства сортировки. Эти поля у всех одинакого типа, для целостности. 

* `BIGSERIAL` (и соответственно `BIGINT`) у всех основных и структурных сущностей как айди, 
так как пользователей может быть много, а следовательно и данных, которые они могут добавить тоже
* `SERIAL` (и соответственно `INT`) как айди у всех сущностей для фильтрации, потому что их ограниченное количество,
откуда админ сайта возьмет одна миллионный вид единиц измерения загадка для меня

* в самом файлике создание табличек есть комментарии, к некоторым чекам и данным 


---


## Бизнес-логика триггеров и функций базы данных

### 1. Защита поля `created_at` от изменений

#### Функция: `protect_created_at()`
**Назначение:** Запрещает изменение поля `created_at` при обновлении записей.

**Бизнес-логика:**
- Поле `created_at` хранит дату создания записи и должно оставаться неизменным в течение всего жизненного цикла объекта
- При попытке изменения `created_at` триггер автоматически восстанавливает исходное значение
- Используется для всех основных таблиц (17 триггеров) для обеспечения целостности временных меток

### 2. Автоматическое обновление поля `updated_at`

#### Функция: `set_updated_at()`
**Назначение:** Автоматически обновляет поле `updated_at` текущей временной меткой при изменении записи.

**Бизнес-логика:**
- Обеспечивает отслеживание времени последнего изменения записи
- Полезно для функций "недавно измененные рецепты", истории редактирования
- Применяется к таблицам, где важен факт обновления: `user`, `recipe`, `review`


### 3. Расчет среднего рейтинга рецепта

#### Функция: `update_recipe_rating()`
**Назначение:** Пересчитывает средний рейтинг рецепта при изменении отзывов.

**Бизнес-логика:**
- Автоматически обновляет поле `rating` в таблице `recipe` при:
  - Добавлении нового отзыва
  - Изменении существующего отзыва
  - Удалении отзыва
- Рассчитывает среднее арифметическое всех активных отзывов (с `deleted_at IS NULL`)
- Округляет результат до 2 знаков после запятой
- Игнорирует удаленные отзывы при расчете

**Триггер:** `trg_review_rating` (срабатывает при INSERT/UPDATE/DELETE в таблице `review`)


### 4. Увеличение счетчика просмотров рецепта

#### Функция: `update_recipe_views()`
**Назначение:** Увеличивает счетчик просмотров при добавлении записи о просмотре.

**Бизнес-логика:**
- Каждый новый просмотр (запись в `recipe_view`) увеличивает `views` в таблице `recipe` на 1
- Обеспечивает реальную статистику популярности рецептов
- Используется для сортировки по популярности, рекомендательных алгоритмов

**Триггер:** `trg_recipe_view_increment` (срабатывает при INSERT в `recipe_view`)


### 5. Управление дубликатами в связующих таблицах (UPSERT-логика)

#### Общий принцип бизнес-логики:
**Назначение:** Предотвращение дублирования связей с поддержкой мягкого удаления.

**Сценарии обработки:**
1. **Запись не существует** → Создать новую
2. **Запись существует и активна (deleted_at IS NULL)** → Игнорировать (предотвратить дубликат)
3. **Запись существует и удалена (deleted_at NOT NULL)** → Создать новую (восстановление связи)

#### 5.1 Простая проверка (для `recipe_category`, `recipe_tag`, `collection_recipe`)
- **Функции:** `upsert_recipe_category()`, `upsert_recipe_tag()`, `upsert_collection_recipe()`
- **Логика:** Проверяет только наличие связи без учета параметров
- **Пример:** Рецепт уже в категории "Десерты" → новый запрос игнорируется

#### 5.2 Проверка с учетом параметров (для `recipe_ingredient`, `shop_list_item`, `review`)
- **Функции:** `upsert_recipe_ingredient()`, `upsert_shop_list_item()`, `upsert_review()`
- **Логика:** Проверяет не только наличие связи, но и параметры (количество, единицы измерения, текст и т.д.)
- **Дополнительная логика:** Если связь существует, но параметры отличаются:
  - Помечает старую запись как удаленную (`deleted_at = CURRENT_TIMESTAMP`)
  - Создает новую запись с обновленными параметрами

----

## Примеры использования представлений

 1. **user_statistics** — Статистика по пользователям

 2. **recipe_detailed_report** — Детальная аналитика рецептов 

 3. **recipe_enhanced** — Рецепты с вычисляемыми полями

 4. **quick_recipes_with_reviews** — Быстрые рецепты с отзывами

 5. **public_user_profiles** — Публичные профили пользователей 


### Практические сценарии использования:

### Для администратора:
```sql
-- Анализ активности сообщества
SELECT 
    COUNT(*) as total_users,
    AVG(total_recipes) as avg_recipes_per_user,
    SUM(total_views_given) as total_community_views
FROM user_statistics;

-- Мониторинг новых пользователей
SELECT username, masked_email, user_level
FROM public_user_profiles
WHERE created_at > CURRENT_DATE - INTERVAL '7 days';
```

### Для рекомендательной системы:
```sql
-- Рекомендовать популярные простые рецепты новичкам
SELECT title, popularity_level, difficulty_level
FROM recipe_enhanced
WHERE difficulty_level = 'Быстрый' 
  AND difficulty_level = 'Простой'
  AND popularity_level IN ('Очень популярный', 'Популярный');
```

### Для пользовательского интерфейса:
```sql
-- Отображение профиля пользователя
SELECT *
FROM public_user_profiles
WHERE id = 2;
```

### Для отчетности:
```sql
-- Еженедельный отчет по контенту
SELECT 
    COUNT(*) as new_recipes,
    AVG(rating) as avg_rating,
    SUM(views) as total_views
FROM recipe_detailed_report
WHERE created_at > CURRENT_DATE - INTERVAL '7 days';
```


